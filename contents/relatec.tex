% !TEX root = ../main.tex
\chapter{web前端性能概述}
在展开研究主题之前，
本章先描述主流web系统的结构，
现代web浏览器的结构和工作模式，
包括浏览器加载(Load)和渲染(Render)模型，
以及web系统中常使用的各种资源。
最后，对现行的各种web性能度量指标，
以及现存改善web前端性能的相关技术，做出总结和归纳。

\section{web系统结构}

现代web系统是经过二十余年的不断完善的结果，
如\autoref{fig:web-arch} 所示。
一个完整的web系统依其服务的复杂，
存在很多不同的系统组件协调运行。
为能较清晰的解释整个流程，
现以用户在地址栏输入网址按下回车，
直到页面呈现在用户眼前的过程为例，
阐述页面加载过程中所涉及的各系统组成。

\begin{figure}[htbp]
	\centering
	\includegraphics[width = 0.6\linewidth]{web-arch}
	\caption{现代web组件}\label{fig:web-arch}
\end{figure}

用户输入地址，浏览器即可开展域名解析工作，
如果缓存和本机 Hosts 文件无法命中，
则向本机配置的域名解析服务器请求（细节略）。
获取到目标主机相应的地址后，
浏览器检查连接池中是否有可复用的连接，
如没有，浏览器的网络模块就开始与目标主机建立连接，
如果连接使用了加密传输协议，
可能还需要请求颁发证书的机构（CA）验证公钥的合法性。
浏览器向目标端口发出 HTTP 请求，
请求可能经过代理，反向代理，
web服务器收到请求后准备提供主文档内容。
当浏览器收到主文档HTML的第一个数据块解压后，
就立即开始解析。
根据主文档上描述的引用资源，
浏览器可能开始向不同的主机发出相应的网络请求，
这其中的每一次请求又将重复前述段落的过程。
资源被加载(加载包括下载和读本地缓存)进当前页面后都需要浏览器进行运算或渲染，
可视化的页面最终才能呈现在用户面前。

从web服务提供商的角度来看，
一个web系统需满足分布在世界各地的用户，
任一用户在享用服务的时候都会在一段时间内触发向不同服务器/代理的请求。
比如单日活跃用户数达10亿的 Facebook 要为全球用户呈现的页面内含上百个不同的静态或动态资源\cite{butkiewicz2011}，
资源按100多种语言要提供相应的版本，
按10,000多种终端平台也要提供不同的适配，
并且还需保证平滑更新这些资源。
在保证服务端正常工作的基础上，
运用、适应整个web体系的运行规则，
并且规避其中的性能陷阱，
合理地设计web前端资源和程序，
以提高交付到分布广泛且差异化的用户端的性能，
是web前端工程师和性能工程师的重要职责。

\section{浏览器相关技术}

从 1992 年第一款浏览器出世直到现在，浏览器的功能愈来愈强大，
毫不夸张的说，浏览器对于前端工程人员几近于一种``操作系统''的存在，
对于广大用户而言，浏览器也是日常使用网络的主要途径。
而移动端用户日常使用的应用，
其实也有相当一部分是混合了 Web View 的混合型应用（Hybrid App）。
所以，为了分析和优化的研究工作顺利开展，有必要详细描述现代浏览器的结构及其运行机制。

\subsection{浏览器从web加载的资源}
在 web系统中，一般把一个可以被访问或者操作的对象称做一个资源，
而且任何一个资源都可以被一个统一资源标识符（URI）唯一标识。
所以，资源是一种信息实体。
严格地说，URI只确定资源实体，并不确定资源的表现形式。
资源的表现形式由应用层网络协议协商确定。
比如HTTP/1.1报头的\texttt{Accept}和\texttt{Content-Type}字段决定了资源的表现形式。

web 页面或web 应用相比本地应用的一个最大差别就是构成使用界面的资源，
web页面资源的表现形式和渠道是非常多样化的。
然而不管在页面初次呈现，还是在后续的交互中，
都需要浏览器不断地有序加载进各种各样的资源。
这其中比起本地应用仅需调用本地资源和编程接口来说无疑增加了更多的复杂性。
在web服务提供者的视角，
会把web系统里的资源区分为静态资源和动态资源，
这取决于当服务端响应HTTP请求后是否需要额外的业务运算逻辑来区分。
现今最常见的动态资源就是动态网页的主文档，
服务端一般仅维护主文档页面的模板，
根据请求传递参数和当时运算，
利用模板引擎将模板转译成HTML内容。
而静态资源的请求仅需响应一个对应的文件就完成。
所以在大部分情况下，浏览器加载动态资源要比请求静态资源更耗时\cite{souders_high_2007, souders_even_2009}。
可无论请求的是动态资源还是静态资源，
对于浏览器的加载来说都是无感知的，
作为内容来传输的资源无法发生改变，
所以，在文献资料中常见``web前端静态资源管理''的表述也就不足为奇了。

接下来结合本文所关注的性能分析视角，
呈述一下浏览器加载的各种表现形式的资源，
以为之后的浏览器加载渲染模型做铺垫。

	\subparagraph{HTML文档}
    HTML 文档是最早运用于web世界的资源表现形式。
    作为一种描述文档结构的标记语言，
    相比过程式的标记语言如\TeX 自由了许多。
    HTML对于浏览器的意义在于它经过解析之后的模型（DOM）。
    这个模型确立了脚本程序如何去访问页面上的内容。
    然而，不管是 HTML 文档标准和 DOM API 标准，
    长期以来都处于一个持续发展的过程中，
    更令人无奈的是，不同的浏览器，浏览器不同的版本，
    都对这些标准有着各自不一的支持程度。
    所有的这些困难，都是应该在web工程中尽力克服的。
    另外，除非是纯静态的web服务，
    一般HTML都是通过模板引擎渲染模板来生成。
    由于HTML繁琐的编写规则和绝对的容错性，
    即使在编写静态页面时，多数人也倾向于使用模板语言编写输出。
    另外，通过客户端脚本异步请求到数据后，
    也惯用模板引擎而不是字符串拼接那些数据来产生HTML片段。
    所以，模板引擎的性能属性也是必须被考虑的内容。

	\subparagraph{样式表（CSS）}
    在早期的HTML文档中，有不少标签用于描述内容的展现形式。
    这种设计方法被日益丰富的web世界所淘汰。
    层叠样式表（CSS）用于描述文档里内容的展现形式，
    和HTML文档一样，CSS也是绝对容错的，
    同样也存在标准的适应性问题。
    CSS规则设定的各种样式属性对应了浏览器的布局和绘图模型，
    本文第四章将详细讨论这些内容对于渲染性能的影响。
    和HTML文档渐进式的解析过程不同，
    CSS文档是一次性无阻塞地完成解析过程并生成规则树。
    规则树再不断地和DOM树结合在一起生成可用于指导布局的渲染树。
    现代浏览器都会为其支持的HTML标签设定默认的样式表，
    所以多数场景下，开发人员需要在首先加载的CSS文档中完成初始化(normalize.css)。
    另外由于CSS3的不断完善，
    web开发人员可以利用CSS3的一些新属性
    实现一些本应用小图片呈现的元素，
    并能完成一些简单的页面动画取代原本需要使用脚本程序甚至Flash技术实现的动画。
    关于此，本文也将在第四章重点分析。

	\subparagraph{脚本程序(JavaScript)}
    在早期，浏览器的客户端脚本程序有很多选择，
    经过工程和市场的考验，历史最终选择了JavaScript，
    故本文所言之``脚本程序''如无特殊说明均指 JavaScript 程序。
    JavaScript 程序可以通过HTML文档中的\texttt{<script>}标签引入。
    JavaScript 程序作为静态资源被加载时默认将阻塞HTML和CSS的解析。
    脚本程序比其他web资源非常不一样的地方在于，
    一旦脚本加载完毕可以执行时，
    脚本程序已经不是一个``静态资源''的存在了。
    web前端开发鼓励充分挖掘脚本程序的潜能以减少不必要的服务端业务逻辑，
    这刺激了JavaScript编程语言的快速发展，标准体系由ECMAScript-262维护。
    依赖于具体脚本解释器的设计，脚本的执行效率在不同终端平台上有很大差别。
    脚本程序通过调用浏览器提供的各种编程接口，包括操作文档和使用HTTP，
    极大地丰富了web页面的业务能力。
    根据\texttt{httparchive.org}统计数据，现今（2016年1月），
    Alexa 排名前1000万的网页中有78\%需要加载超过10个脚本资源，
    脚本资源的加载和执行对前端性能的影响将在本文中重点研究。

    \subparagraph{图片及其他多媒体资源}
    从信息传递的角度来看，
    图片等多媒体资源的传递效率比之文字要高上不少。
    web中使用的图片包括位图和矢量图。
    矢量图由SVG格式实现，适用于几何感强和色彩简单的元素，
    常用于LOGO标记和扁平化设计里的背景图。
    由于SVG是基于XML的格式，所以可以采用适用纯文本压缩的GZIP。
    位图是在web页面中最多见的图片类型，本文后所指图片如无特殊说明均指此种。
    由于位图原始格式需要记录图片每一个像素信息，
    所以平常所见的jpg、png、gif都是指图片的压缩格式。
    图片文件中除了存储了图片本身的数据以外，
    还有许多对于web前端来说冗余的数据，
    比如，一个jpeg图片中会含有一些EXIF元数据，
    用来描述相机拍摄时记录的信息；
    而png格式的图片除了元数据有时还包含一个缩略图。
    针对这种情况，常常需要对图片进行再一次的无损压缩工作。
    图片资源的大小通常从几KB到几百KB不等，
    虽然图片资源的加载并不阻塞浏览器的任何工作，
    但在用户交互阶段时频繁的图片加载，
    或某些本身以图片内容为主营业务的网站，
    提高图片的加载和呈现效率是很重要的工作。

业界一直有这样的说法，在软件工程的世界里，
只有两个永恒的问题——命名和缓存\cite{saternos2014client}。
对于静态资源来说，浏览器的加载模块从网络中加载肯定比从本地加载更加耗时。
浏览器方面的缓存一般分为本地缓存和缓存协商，
如果一个资源被配置了强缓存(响应报文头\texttt{Expires}或\texttt{Cache-Control})，
那么加载时不用对资源的目标主机发起请求，
而是直接从本地加载完成。
在实践中，给资源名追加文件指纹并设置强缓存，
是保证平滑更新资源的重要手段。
如果是缓存协商（请求报文头\texttt{Last-Modified, If-Modified-Since}和\texttt{ETag, If-None-Match}），
则浏览器仍旧需要去请求服务器，
如果得到的是304（Not Modified）响应，
则不必去加载这个资源。
在用户手动刷新网页时，浏览器资源加载器会跳过强缓存，但不会跳过缓存协商。
缓存机制在web系统中是广泛存在的，
所以，尽一切可能在web系统的各层级缓存资源，
是提高总体性能的重要任务。

\subsection{浏览器结构及运行机制}
如\autoref{fig:browser-arch}所示，
浏览器的基本部分主要包括用户界面、渲染引擎、脚本解释器、渲染后端、网络组件和持久化数据模块。
不同浏览器实现这些模块的方式都不完全相同。
本文主要讨论使用webkit系的浏览器：
Safari9, Firefox, Chrome\footnote{Chrome使用webkit的分支项目Blink}，
另由于国内仍有近1/3的用户在使用IE9浏览器，所以实验也包括IE9。
\begin{figure}[htbp]
	\centering
	\includegraphics[width = 0.6\linewidth]{browser-arch}
	\caption{现代浏览器结构图}\label{fig:browser-arch}
\end{figure}

正是因为浏览器本身蕴含的平台特征，
浏览器的研发工作得到了各大顶尖科技公司的重视，
在浏览器技术上保持领先的科技公司甚至直接参与制定相关业界标准。
所以，研究现代浏览器的设计思路，有助于把握性能实践在浏览器层面的要素。

为了满足``更快、更稳定、更安全''的设计愿景，
完整的现代浏览器结构是非常复杂的，
例如开源浏览器Chromium的源码行数已达1300万行，
与最新的Linux内核1800万行的量级相当。
接下来，为性能分析之便，此处仅以浏览器处理和呈现资源的流程为中心，
按流程内处理资源的差异，总结一套浏览器工作流程模型，
如\autoref{fig:browser-workflow} 所示。
\begin{figure}[htbp]
	\centering
	\includegraphics[width = 0.9\linewidth]{browser-workflow}
	\caption{浏览器运行机制}\label{fig:browser-workflow}
\end{figure}

考虑用户访问一个网页的情景，
\textbf{资源加载器}从网络或者本机存储中加载网页主文档HTML。
当主文档的第一个数据块开始加载到浏览器后，
就被送到\textbf{文档解析器}里进行解析，
文档解析器将持续地解析着主文档里的每一个标签。
解析标签的过程，就是将HTML字符串转化成DOM节点的过程，
最终整个HTML文档将被解析成一棵 DOM 树。

在文档解析过程中遇到了引用了外部资源的标签时，
比如遇到
\begin{lstlisting}
<link rel="stylesheet" href="main_2j3a31.css">
\end{lstlisting}
资源加载器负责加载这个样式表，
和HTML不一样的地方是，当加载完成后，
文档解析器才将样式表定义的一系列规则转化成一系列样式对象(CSSOM)，
并将这一系列对象组成一棵样式规则树。
注意即使没有引用任何样式表或定义任何样式，
现代浏览器也会定义一套默认样式表，
所有的解析完成后的CSS规则树都会持续地和DOM树结合在一起，生成渲染树(Render tree)。
渲染树经过布局、绘制、合并图层等复杂操作，才得以将生动的web页面呈现出来。

当文档解析到了引用脚本程序的标签时，
比如
\begin{lstlisting}
<script type="javascript" src="vha_s13aja0.js"></script>
\end{lstlisting}
加载器加载完时，
通常\textbf{脚本解释器}会开始工作，
并且阻塞所有可能更新渲染树的行为，
除非引用此脚本的标签里明确标记了\texttt{defer}或\texttt{async}属性使该脚本等待文档解析完成后执行。

当浏览器将渲染树构造好之后，
\textbf{渲染模块}将绘制或重新绘制当前画面，
部分浏览器将开始绘制的时间点在时间活动面板上
标记一根``绿线''。
渲染模块将绘图单元按照框的模型进行布局，
再按层的模型进行绘制，
这个过程中需要调用操作系统提供的图形接口，
甚至通过GPU的协助，才能将所需画面呈现在屏幕上。

当加载的资源又动态地引入新资源时，
情况又变得复杂起来，将在本文第三章讨论。
当文档解析器将主文档里的所有标签都解析完成后，
被延迟(defer)的客户端脚本程序开始执行，
并触发(Fired)一个 DOMContentLoaded事件，
通常在性能分析常用的瀑布图里会将此时间点标记一根蓝线。
一般情况下，为操作DOM而编写的脚本程序需要监听到这个事件才执行。
在这之后，浏览器将继续加载之前可能还没加载完的资源(一般是图片)。
通过广泛使用的脚本化HTTP请求技术(Ajax\footnote{``异步JavaScript和XML''的名称不具备自明性，所以如此表述。})，
浏览器将会在保证安全的策略\footnote{同源策略}下继续加载新的资源。
当所有的资源都加载完成后，浏览器本身触发一个load事件，
通常在性能分析的瀑布图里会将此时间点标记一根红线，表示页面加载完成。

页面加载完成并不代表浏览器在这个页面的工作就结束了，
因为用户操作或客户端脚本的异步请求，随时可能会加载新的资源，
通过各种手段实现的页面动画，也让浏览器的布局或绘图模块无法停下来。
用户进一步的交互行为又将产生新的事件（Event），
通过监听某些事件执行的客户端脚本，可能会通过操作DOM或加载新内容，
使浏览器的各组件又如初次加载页面那般运转起来。

根据StatCounter提供数据，
在国际市场下，从2010年至今（2016年1月），
来自IE, Chrome, Firefox, Safari浏览器的访问量变化如
\autoref{fig:browser-trends} 表示，
可见Chrome浏览器凭借着其卓越的性能表现保持稳定的市场优势。
由于IE浏览器在支持新标准上的相对落后和移动网络的崛起
即使在中国大陆市场下，IE的市场份额也已经下降至30\%以下（百度流量研究院数据）。
所以本文之后会重点研究在以webkit系为渲染引擎的浏览器下
的性能分析优化工作。

\begin{figure}[htbp]
	\centering
	\includegraphics[width = \linewidth]{browser-trends}
	\caption{2010年至今浏览器市场份额趋势}\label{fig:browser-trends}
\end{figure}


\section{web前端性能度量指标}

关于web前端性能的度量层面，业界已经有了非常多的度量指标。
一部分重点关注网络相关的指标，而另一部分重点关注运算方面的指标，

使用HTTP监测工具或浏览器网络瀑布图，
可以直观的看到各种页面资源的加载时间线和HTTP的请求响应报头的细节。
对于自动化或批量的性能测试，需要实现一套规范能文本化的表达这些信息，
这样的规范就是HAR（HTTP Archive）规范。
目前（2016年1月）HAR规范的最新版本为HAR1.2\cite{harspec}，
HAR使用JSON格式组织数据，
其中记录了浏览器或其他用户代理每一个请求和其对应响应的各种信息，
包括资源大小、压缩量、是否缓存、加载时间分片、协议类型等等。
著名的\texttt{httparchive.org}就是通过不断采集全球Alexa排名前3000万的网页
来记录web页面的变迁历史。

由W3C组织的web性能工作小组订立的 Navigation Timing API 确立了一系列时间节点\autoref{fig:w3c-navtime}\cite{w3cnavi} 。
\begin{figure}[htbp]
	\centering
	\includegraphics[width = \linewidth]{w3c-navtime}
	\caption{W3C性能计时时间线}\label{fig:w3c-navtime}
\end{figure}
其中被广泛利用的是DOMContentLoaded事件的触发线（蓝线）和浏览器load（红线)。
在前述介绍浏览器工作模型中已经提到，蓝线仅意味着主文档解析完成，以便需要操作DOM的脚本程序尽快得到执行。
而红线则意味着所有的资源都已经获取并运算/解码/执行完了。
遵循W3C规范的浏览器都支持这两个事件，甚至包括无头浏览器 phantom.js ，
这的确大大方便了页面加载性能的测量。
但是经过多次实验和分析，
本文认为，红蓝两线是浏览器视角的测定指标，
用于部分需要依赖某些页面元素存在的脚本程序使用，
太过机械化，不可简单的以此时间线判定页面性能的优劣。

有用户研究实验\cite{balasubramanianweb}针对30个Alexa排名前200的网站，
将一组用户判定页面呈现完成的时间和
实际的页面加载时间作出对比，
发现有超过50\%的用户判定呈现完成的时间早于实际的页面加载时间，
有20\%左右的用户判定呈现完成的时间远超于实际的页面加载时间。
这个实验结果说明用户只会在意页面加载时的呈现感，
而加载时间只是呈现感流畅的一方面而已。

web页面或web应用是用户使用的，理应从用户的视觉观感出发来衡量。
所以，围绕浏览器的绘制过程可以确立一系列度量指标。
比如，初绘时间(First Paint)，标识着浏览器开始绘制第一个像素点的时间。
在 Chrome 浏览器的性能分析时间线中一般以一根绿线标识，
释放事件\texttt{FirstPaint}。
在这之前的这段时间，浏览器页面区域显示一块空白，
国内性能监测平台称之为``白屏时间''。
类似的，还有在第三方web性能评估工具中广泛使用的首屏时间（Above-the-fold time)，
是指浏览器绘制过程中，用户可见的窗口区域内绘图完毕的时间。
初绘时间和首屏时间的度量方法，忽略了在绘制过程中的中间状态，
因此，为了描述绘制过程，
知名第三方页面加载性能测试平台 WebPageTest 在2013年提供了一个速度指数（Speed Index）指标用于描述页面加载过程。
该指标的计算方法需要在页面加载过程中记录绘制画面，
以100毫秒为间隔记录画面，直到加载完成将得到一个绘制完成度（Visually complete）的序列。求$\int _{0}^{end}{(1-vc)}$得到的值即是速度指数，
速度指数的值越小，说明页面加载呈现的越快，
从\autoref{fig:speed-index-curve} 可以很直观的看出速度指数的值即是完成度曲线图上方的区域面积。
速度指数指标在2013年后被HAR标准采纳，
通过使用 Google BigQuery 查询httparchive.org每半月存储的数据，
检索Alexa排名前1000名的网站中速度指数的分布（如\autoref{fig:popularity-speedindex}）
可以发现排名靠前的网站有90\%都优于均值，而且密集分布在3000附近。
\begin{figure}[htbp]
	\centering
	\includegraphics[width = .6\linewidth]{speed-index-curve}
	\caption{绘制完成度曲线}\label{fig:speed-index-curve}
\end{figure}
\begin{figure}[htbp]
	\centering
	\includegraphics[width = .9\linewidth]{popularity-speedindex}
	\caption{Alexa排名前1000名的网站速度指数分布}\label{fig:popularity-speedindex}
\end{figure}

在渲染绘图方面，
浏览器绘制一张画面称为一帧（Frame），
每秒能够绘制的画面数被称为帧率（FPS）。
为了给用户提供流畅的体验，
业内通常以60 FPS作为流畅呈现的目标。
这个指标通常适用页面交互和动画时使用，
本文将在第四章详细研究。

\section{本章小结}
本章为后文的研究展开准备了浏览器的运行机制等基础模型，
并从性能角度重点分析了几种web页面使用的静态资源情况，
另外介绍了文中将用到的相关性能指标。


